/**
 * Author: derselbst
 * Description: provides functions that are used by the worker processes to check whether a bruteforced string generated by the master process matches pwdHash
 */

#include <iostream>
#include <cstring> // memcmp()
#include <string>
#include <queue>
#include <limits>
#include <openssl/sha.h>
#include <byteswap.h>
#include <mpi.h>

using namespace std;

#include "worker.h"
#include "master.h"

// contains the hash of the unknown password
char pwdHash[SHA256_DIGEST_LENGTH];

// contains the hash of a bruteforced string
char bruteHash[SHA256_DIGEST_LENGTH];

// used when sending messages
enum MpiMsgTag
{
    task,
    success // hashes match, unused ATM
};

/**
 * @brief prints 32 bytes of memory
 *
 * prints a hex dump of 32 bytes of memory pointed to
 *
 * @param[in]   pbuf: pointer to some memory, usually containing an SHA256 hash
 */
void printSHAHash(const unsigned int *const pbuf)
{
    // byteswap the integer pointed to, to display hex dump in correct order
    // TODO: how to deal with big endian machines
    cout << std::hex << std::uppercase
         << bswap_32(*(pbuf))
         << bswap_32(*(pbuf+1))
         << bswap_32(*(pbuf+2))
         << bswap_32(*(pbuf+3))
         << bswap_32(*(pbuf+4))
         << bswap_32(*(pbuf+5))
         << bswap_32(*(pbuf+6))
         << bswap_32(*(pbuf+7))
         << endl;
}

/**
 * @brief generates an SHA256 hash
 *
 * generates an SHA256 hash using openSSL
 *
 * @param[in]      input:   a const pointer to const block of data, usually a char array of which the hash is being generated
 * @param[in]      length:  the number of bytes the that input points to holds
 * @param[in,out]  hashStr: const pointer to an array of SHA256_DIGEST_LENGTH bytes that will receive the hash
 *
 * @return returns true if the hash has been generated successfully; returns false if input or hashStr is NULL or length==0; else: false
 */
bool generateSHA256(const void *const input, const size_t &length, char *const hashStr)
{
    if(!hashStr || !input || length==0)
    {
        return false;
    }

    SHA256_CTX hash;
    if(!SHA256_Init(&hash))
    {
        return false;
    }

    if(!SHA256_Update(&hash, input, length))
    {
        return false;
    }

    if(!SHA256_Final(reinterpret_cast<unsigned char*>(hashStr), &hash))
    {
        return false;
    }

    return true;
}

/**
 * @brief checks equality of two hashes
 *
 * calculates the SHA256 hash of 'password' and compares it
 * with the initial password hash
 *
 * @param[in]   password: a const string containing a guessed password
 *
 * @return returns true if hashes match; false if generation of hash failed or hashes not match
 */
bool checkPassword(const string &password)
{
#ifdef VERBOSE
    cout << "checking " << password << endl;
#endif // VERBOSE

    // generate sha hash from entered string and write it to pwdHash
    if(!generateSHA256(password.c_str(), password.length(), bruteHash))
    {
        cerr << "Error when generating SHA256 from \"" << password << "\"" << endl;
        return false;
    }

    if (!memcmp(bruteHash, pwdHash, SHA256_DIGEST_LENGTH))
    {
        cout << "match [" << password << "]" << endl << "hash: " << endl;
        printSHAHash((unsigned int*)bruteHash);
        return true;
    }

    return false;
}

/**
 * @brief the main loop for a worker process
 * 
 * continuously looks for incoming strings, generates the SHA
 * hash of it and checks if it matches the secret hash
 */
void worker()
{
    char* buf=NULL;
    MPI_Status state;

    while(true)
    {
        // check for new msg
        MPI_Probe(MasterProcess, task, MPI_COMM_WORLD, &state);

        int len;
        // now check status to determine how many bytes were actually received
        MPI_Get_count(&state, MPI_BYTE, &len);

        // allocate len bytes
        buf=new char[len];
        // TODO: check whether allocation succeeded

        // receive len bytes
        MPI_Recv(buf, len, MPI_BYTE, MasterProcess, task, MPI_COMM_WORLD, &state);

        string str(buf, len);
        delete [] buf;
        buf=NULL;

        if(checkPassword(str))
        {
            //success, tell master
            //MPI_Send(const_cast<char*>(str.c_str()), str.length(), MPI_CHAR, MasterProcess, success, MPI_COMM_WORLD);
            cout << "Password found: " << str << endl;
            MPI_Abort(MPI_COMM_WORLD, 0);

            break;
        }
    }
}

